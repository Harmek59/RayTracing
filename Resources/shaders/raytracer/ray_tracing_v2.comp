#version 430

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform image2D img_color;

layout(rgba32f, binding = 1) uniform image2D img_position;
layout(rgba16f, binding = 2) uniform image2D img_direction;

uniform int recursionDepth = 5;
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;

uniform int imageWidth = 1280;
uniform int imageHeight = 720;

uniform float fov = 45.;



ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

float INFINITY = 1.0 / 0.0;
//////////////////////
struct TriangleFromMesh{
    uint  vertexIndex1;
    uint  vertexIndex2;
    uint  vertexIndex3;

    uint  material;
};

struct VertexFromMesh{
    float x;
    float y;
    float z;
    uint offset;
};
uniform uint numberOfTrianglesFromMesh = 0;
layout (std140, binding = 8) readonly buffer TRIANGLE_FROM_MESH
{
    TriangleFromMesh trianglesFromMesh[];
};

layout (std140, binding = 9) readonly buffer VERTEX_FROM_MESH
{
    VertexFromMesh verticesFromMesh[];
};

////////
ivec3 cellsIndexTo3D(uint idx, ivec3 gridResolution) {
    int z = int(float(idx) / float(gridResolution.x * gridResolution.y));
    idx = idx - int(z * gridResolution.x * gridResolution.y);
    int y = int(float(idx) / float(gridResolution.x));
    int x = int(mod(float(idx), float(gridResolution.x)));
    return ivec3(x, y, z);
}

uint cells3DToIndex(ivec3 cords, ivec3 gridResolution){
    return (cords.z * gridResolution.x * gridResolution.y) + (cords.y * gridResolution.x) + cords.x;

}

struct Cell {
    uint beginOfTrianglesIndiciesArray;
    uint endOfTrianglesIndiciesArray;
    uint offset;
    uint offset2;
};
struct TriangleIndicesInGrid{
    uint index;
    vec3 offset;
};
layout (std140, binding = 10) readonly buffer TRIANGLE_IN_GRID
{
    uint trianglesIndicesInGrid[];
};

layout (std140, binding = 11) readonly buffer CELLS
{
    Cell cells[];
};

struct GridData{
    vec3 gridBegin;
    uint cellsBeginIndex;
    vec3 gridEnd;
    uint cellsEndIndex;
    ivec3 gridResolution;
    int offset1;
    vec3 cellSize;
    int offset2;
};

//uniform int numberOfGrids = 7;
layout (std140, binding = 12) readonly buffer GRIDSDATA
{
    GridData gridData[];
};

////////////////////
struct Ray
{
    vec3 origin;
    vec3 direction;
    vec3 energy;
};

struct Sphere
{
    vec3 position;
    float radius;
    vec4 albedo;
//float a;
    vec4 specular;
//float a2;
};

struct Triangle{
    vec3 vert0;
    float offset1;
    vec3 vert1;
    float offset2;
    vec3 vert2;
    float offset3;
    vec3 albedo;
    float offset4;
    vec3 specular;
};


struct HitPoint
{
    vec3 position;
    vec3 normal;
    float dist;
    vec3 albedo;
    vec3 specular;
};

struct Light
{
    vec3 position;
    float offset1;
    vec3 color;
    float offset2;
    vec3 offset3;
    float radius;

};

uniform int numberOfSpheres = 10;
layout (std140, binding = 1) uniform SPHERES
{
    Sphere      spheres[128];
};


int numberOfTriangles = 12;
layout (std140, binding = 2) uniform TRIANGLES
{
    Triangle     triangles[12];
};

uniform int numberOfLights = 5;
layout (std140, binding = 3) uniform LIGHTS
{
    Light      lights[128];
};




Ray createFirstRay();

vec3 shade(Ray ray, HitPoint bestHit);

bool intersectRaySphere(Ray ray, Sphere sphere, inout HitPoint bestHit);//return true if we hit and update bestHit only it it is closer

HitPoint trace(Ray ray);

void updateRay(inout Ray ray, HitPoint bestHit);

bool intersectBox(Ray ray, vec3 boxMin, vec3 boxMax, out float tHitBox);

void DDA(Ray ray, GridData grid, float tHitBox, inout HitPoint bestHit);

bool intersectTriangle(Ray ray, Triangle triangle, inout HitPoint bestHit)
{
    //https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
    const float EPSILON = 0.0000001;
    vec3 vertex0 = triangle.vert0;
    vec3 vertex1 = triangle.vert1;
    vec3 vertex2 = triangle.vert2;
    vec3 edge1, edge2, h, s, q;
    float a, f, u, v;
    edge1 = vertex1 - vertex0;
    edge2 = vertex2 - vertex0;
    h = cross(ray.direction, edge2);
    a = dot(edge1, h);
    if (a > -EPSILON && a < EPSILON)
    return false;// This ray is parallel to this triangle.
    f = 1.0/a;
    s = ray.origin - vertex0;
    u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
    return false;
    q = cross(s, edge1);
    v = f * dot(ray.direction, q);
    if (v < 0.0 || u + v > 1.0)
    return false;
    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = f * dot(edge2, q);
    if (t > EPSILON)// ray intersection
    {
        if (t < bestHit.dist){
            bestHit.dist = t;
            bestHit.position = ray.origin + t * ray.direction;
            bestHit.normal = normalize(cross(edge1, edge2));
            bestHit.albedo = triangle.albedo;
            bestHit.specular = triangle.specular;
            return true;
        }
        return false;
    }
    else // This means that there is a line intersection but not a ray intersection.
    return false;
}

void main()
{
    Ray ray = createFirstRay();

    vec3 color = vec3(0.0, 0.0, 0.0);

    for (int recursion = 0; recursion < recursionDepth; recursion++){

        HitPoint hit = trace(ray);
        updateRay(ray, hit);
        color += shade(ray, hit)* ray.energy;
        ray.energy = ray.energy * hit.specular;

    }

    if (trianglesIndicesInGrid[1] != 611){
        color = vec3(1.0, 0.0, 0.0);
    } else if (cells[1].beginOfTrianglesIndiciesArray != 1 || cells[1].endOfTrianglesIndiciesArray != 2){
        color = vec3(0.0, 1.0, 0.0);
    }


    imageStore(img_color, pixel_coords, vec4(color, 1.0));
}

bool intersectRaySphere(Ray ray, Sphere sphere, inout HitPoint bestHit)
{
    vec3 v = ray.origin - sphere.position;
    float B = 2.0 * dot(ray.direction, v);
    float C = dot(v, v) - sphere.radius * sphere.radius;
    float B2 = B * B;

    float f = B2 - 4.0 * C;

    if (f < 0.0)
    return false;

    f = sqrt(f);
    float t0 = -B + f;
    float t1 = -B - f;
    float t = min(max(t0, 0.0), max(t1, 0.0)) * 0.5;

    if (t == 0.0)
    return false;

    if (t < bestHit.dist){
        bestHit.dist = t;
        bestHit.position = ray.origin + t * ray.direction;
        bestHit.normal = normalize(bestHit.position - sphere.position);
        bestHit.albedo = sphere.albedo.xyz;
        bestHit.specular = sphere.specular.xyz;
    }


    return true;
}


Ray createFirstRay()
{

    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    pixel_coords = ivec2(ivec2(gl_GlobalInvocationID.x, imageHeight-1 - gl_GlobalInvocationID.y));

    float fov_scale = tan(radians(fov)/2.);
    float imageAspectRatio = float(imageWidth)/ float(imageHeight);

    float pixelCamera_x = (2. * (pixel_coords.x + 0.5) / float(imageWidth) - 1.) * imageAspectRatio * fov_scale;
    float pixelCamera_y = (1. - 2. * (pixel_coords.y + 0.5) / float(imageHeight)) * fov_scale;

    vec3 position = cameraPosition;
    vec3 direction = (viewMatrix * vec4(vec3(pixelCamera_x, pixelCamera_y, -1.), 1.0)).xyz;

    direction = normalize(direction - position);//subtrack cameraPosition because we have position saved in position variable and adding position of camera to direction would mess up direcion vectors

    Ray ray;
    ray.direction = direction;
    ray.origin = position;
    ray.energy = vec3(1.0, 1.0, 1.0);
    return ray;
}

HitPoint trace(Ray ray)
{
    vec3 triangleSpecular = vec3(0.1);

    Triangle triangle;
    triangle.vert2 = vec3(100.0, -20.0, 100.0);
    triangle.vert0 = vec3(100.0, -20.0, -100.0);
    triangle.vert1 = vec3(-100.0, -20.0, 100.0);
    triangle.albedo = vec3(1.0, 0.0, 0.0);
    triangle.specular = triangleSpecular;

    Triangle triangle2;
    triangle2.vert2 = vec3(100.0, -20.0, -100.0);
    triangle2.vert0 = vec3(-100.0, -20.0, -100.0);
    triangle2.vert1 = vec3(-100.0, -20.0, 100.0);
    triangle2.albedo = vec3(1.0, 0.0, 0.0);
    triangle2.specular = triangleSpecular;

    Triangle triangle3;
    triangle3.vert1 = vec3(100.0, -20.0, 100.0);
    triangle3.vert0 = vec3(100.0, 200.0, 100.0);
    triangle3.vert2 = vec3(-100.0, 200.0, 100.0);
    triangle3.albedo = vec3(0.0, 0.7, 0.0);
    triangle3.specular = triangleSpecular;

    Triangle triangle4;
    triangle4.vert1 = vec3(-100.0, 200.0, 100.0);
    triangle4.vert0 = vec3(-100.0, -20.0, 100.0);
    triangle4.vert2 = vec3(100.0, -20.0, 100.0);
    triangle4.albedo = vec3(0.0, 0.7, 0.0);
    triangle4.specular = triangleSpecular;

    Triangle triangle5;
    triangle5.vert2 = vec3(100.0, -20.0, -100.0);
    triangle5.vert0 = vec3(100.0, 200.0, -100.0);
    triangle5.vert1 = vec3(-100.0, 200.0, -100.0);
    triangle5.albedo = vec3(0.0, 0.7, 0.0);
    triangle5.specular = triangleSpecular;

    Triangle triangle6;
    triangle6.vert0 = vec3(-100.0, 200.0, -100.0);
    triangle6.vert1 = vec3(-100.0, -20.0, -100.0);
    triangle6.vert2 = vec3(100.0, -20.0, -100.0);
    triangle6.albedo = vec3(0.0, 0.7, 0.0);
    triangle6.specular = triangleSpecular;

    Triangle triangle7;
    triangle7.vert0 = vec3(-100.0, 200.0, -100.0);
    triangle7.vert1 = vec3(-100.0, -20.0, 100.0);
    triangle7.vert2 = vec3(-100.0, -20.0, -100.0);
    triangle7.albedo = vec3(0.0, 0.7, 0.0);
    triangle7.specular = triangleSpecular;

    Triangle triangle8;
    triangle8.vert0 = vec3(-100.0, -20.0, 100.0);
    triangle8.vert1 = vec3(-100.0, 200.0, -100.0);
    triangle8.vert2 = vec3(-100.0, 200.0, 100.0);
    triangle8.albedo = vec3(0.0, 0.7, 0.0);
    triangle8.specular = triangleSpecular;

    Triangle triangle9;
    triangle9.vert2 = vec3(100.0, 200.0, -100.0);
    triangle9.vert1 = vec3(100.0, -20.0, 100.0);
    triangle9.vert0 = vec3(100.0, -20.0, -100.0);
    triangle9.albedo = vec3(0.0, 0.7, 0.0);
    triangle9.specular = triangleSpecular;

    Triangle triangle10;
    triangle10.vert2 = vec3(100.0, -20.0, 100.0);
    triangle10.vert1 = vec3(100.0, 200.0, -100.0);
    triangle10.vert0 = vec3(100.0, 200.0, 100.0);
    triangle10.albedo = vec3(0.0, 0.7, 0.0);
    triangle10.specular = triangleSpecular;

    HitPoint bestHit;
    bestHit.dist = INFINITY;

    intersectTriangle(ray, triangle, bestHit);
    intersectTriangle(ray, triangle2, bestHit);
//    intersectTriangle(ray, triangle3, bestHit);
//    intersectTriangle(ray, triangle4, bestHit);
    intersectTriangle(ray, triangle5, bestHit);
    intersectTriangle(ray, triangle6, bestHit);
//    intersectTriangle(ray, triangle7, bestHit);
//    intersectTriangle(ray, triangle8, bestHit);
//    intersectTriangle(ray, triangle9, bestHit);
//    intersectTriangle(ray, triangle10, bestHit);

    for (int i = 0; i<gridData.length(); i++){
        float tHitBox;
        if (intersectBox(ray, gridData[i].gridBegin, gridData[i].gridEnd, tHitBox))
        {
            DDA(ray, gridData[i], tHitBox, bestHit);
        }
    }

//    for (uint i = 0; i<numberOfTriangles; ++i)
//    {
//        intersectTriangle(ray, triangles[i], bestHit);
//    }

    for (uint i = 0; i<numberOfSpheres; ++i)
    {
        intersectRaySphere(ray, spheres[i], bestHit);
    }


    return bestHit;
}

void updateRay(inout Ray ray, HitPoint bestHit){
    if (bestHit.dist < INFINITY)
    {
        ray.origin = bestHit.position + bestHit.normal * 0.001;//move a it position along normal vector to not hit same object due to float precision error
        // shadow-acne !
        ray.direction = normalize(reflect(ray.direction, bestHit.normal));
    }
}

vec3 shade(Ray ray, HitPoint bestHit){
    if (bestHit.dist < INFINITY)
    {

        vec3 color = bestHit.albedo / 20.;

        Ray shadowRay;

        vec3 directionalLight = vec3(-0.2, -1.0, -0.3);
        float lightIntensity = 0.8;

        shadowRay.origin = bestHit.position + 0.001 * bestHit.normal;
        shadowRay.direction = -directionalLight;
        HitPoint shadowHit = trace(shadowRay);
        if (!(shadowHit.dist < INFINITY))
        color += clamp(dot(bestHit.normal, directionalLight) * -1, 0.0, 1.0) * lightIntensity;


        for (int i = 0; i<numberOfLights; ++i){
            float dist = length(bestHit.position - lights[i].position);
            if (dist < lights[i].radius){
                Ray shadowRay;
                shadowRay.origin = bestHit.position + 0.001 * bestHit.normal;
                shadowRay.direction = normalize(lights[i].position - bestHit.position);
                HitPoint shadowHit = trace(shadowRay);

                vec3 V = normalize(-bestHit.position);
                vec3 L = normalize(lights[i].position - bestHit.position);
                vec3 N = bestHit.normal;
                vec3 R = reflect(-L, N);

                float rim = clamp(dot(N, V), 0.0, 1.0);
                rim = smoothstep(0.0, 1.0, 1.0 - rim);
                float diff = clamp(dot(N, L), 0.0, 1.0);
                float spec = pow(clamp(dot(R, N), 0.0, 1.0), 260.0);

                //                vec3 rim_color = vec3(0.0); // , 0.2, 0.2);
                //                vec3 diff_color = vec3(0.125); // , 0.8, 0.8);
                vec3 rim_color = vec3(0.0, 0.2, 0.2);
                vec3 diff_color = vec3(0.125, 0.8, 0.8);
                vec3 spec_color = vec3(0.1);

                if (!(shadowHit.dist < dist))
                color += (rim_color * rim + diff_color * diff + spec_color * spec) * (1.-(dist/lights[i].radius));

            }
        }

        return color * bestHit.albedo + vec3(0.1);


    }
    else
    {
        return vec3(0.0);
        return vec3(0.1, 0.1, 0.5);
    }
}

bool intersectBox(Ray ray, vec3 boxMin, vec3 boxMax, out float tHitBox)
{
    float tmin = (boxMin.x - ray.origin.x) / ray.direction.x;
    float tmax = (boxMax.x - ray.origin.x) / ray.direction.x;

    if (tmin > tmax) {
        float temp = tmin;
        tmin = tmax;
        tmax = temp;
    }

    float tymin = (boxMin.y - ray.origin.y) / ray.direction.y;
    float tymax = (boxMax.y - ray.origin.y) / ray.direction.y;

    if (tymin > tymax){
        float temp = tymin;
        tymin = tymax;
        tymax = temp;
    }

    if ((tmin > tymax) || (tymin > tmax))
    return false;

    if (tymin > tmin)
    tmin = tymin;

    if (tymax < tmax)
    tmax = tymax;

    float tzmin = (boxMin.z - ray.origin.z) / ray.direction.z;
    float tzmax = (boxMax.z - ray.origin.z) / ray.direction.z;

    if (tzmin > tzmax){
        float temp = tzmin;
        tzmin = tzmax;
        tzmax = temp;
    }

    if ((tmin > tzmax) || (tzmin > tmax))
    return false;

    if (tzmin > tmin)
    tmin = tzmin;

    if (tzmax < tmax)
    tmax = tzmax;

    tHitBox = tmin;

    return true;
}

void DDA(Ray ray, GridData grid, float tHitBox, inout HitPoint bestHit){
    vec3 deltaT, nextCrossingT;
    ivec3 exit, step, cell;

    vec3 rayOrigCell =  (ray.origin + ray.direction * tHitBox) - grid.gridBegin;
    //    cell.x = int(clamp(floor(float(rayOrigCell.x) / grid.cellSize.x), 0, grid.gridResolution.x - 1));
    //    cell.y = int(clamp(floor(float(rayOrigCell.y) / grid.cellSize.y), 0, grid.gridResolution.y - 1));
    //    cell.z = int(clamp(floor(float(rayOrigCell.z) / grid.cellSize.z), 0, grid.gridResolution.z - 1));

    cell = clamp(ivec3(floor(rayOrigCell / grid.cellSize)), ivec3(0), grid.gridResolution - ivec3(1));


    if (ray.direction.x < 0){
        deltaT.x = - grid.cellSize.x / ray.direction.x;
        nextCrossingT.x = tHitBox + (cell.x * grid.cellSize.x - rayOrigCell.x) / ray.direction.x;
        exit.x = -1;
        step.x = -1;
    } else {
        deltaT.x = grid.cellSize.x / ray.direction.x;
        nextCrossingT.x = tHitBox + ((cell.x + 1) * grid.cellSize.x - rayOrigCell.x) / ray.direction.x;
        exit.x = grid.gridResolution.x;
        step.x = 1;
    }
    if (ray.direction.y < 0){
        deltaT.y = - grid.cellSize.y / ray.direction.y;
        nextCrossingT.y = tHitBox + (cell.y * grid.cellSize.y - rayOrigCell.y) / ray.direction.y;
        exit.y = -1;
        step.y = -1;
    } else {
        deltaT.y = grid.cellSize.y / ray.direction.y;
        nextCrossingT.y = tHitBox + ((cell.y + 1) * grid.cellSize.y - rayOrigCell.y) / ray.direction.y;
        exit.y = grid.gridResolution.y;
        step.y = 1;
    }
    if (ray.direction.z < 0){
        deltaT.z = - grid.cellSize.z / ray.direction.z;
        nextCrossingT.z = tHitBox + (cell.z * grid.cellSize.z - rayOrigCell.z) / ray.direction.z;
        exit.z = -1;
        step.z = -1;
    } else {
        deltaT.z = grid.cellSize.z / ray.direction.z;
        nextCrossingT.z = tHitBox + ((cell.z + 1) * grid.cellSize.z - rayOrigCell.z) / ray.direction.z;
        exit.z = grid.gridResolution.z;
        step.z = 1;
    }


    while (true){
        uint o = cell.z * grid.gridResolution.x * grid.gridResolution.y + cell.y * grid.gridResolution.x+cell.x;
        uint c = o + grid.cellsBeginIndex;//cells3DToIndex(cellIndex, grid.gridResolution);
        //        Sphere sphere;
        //        sphere.position = vec3(cell) * grid.cellSize + grid.gridBegin + grid.cellSize/2.;
        //        sphere.radius =   min(grid.cellSize.x, min(grid.cellSize.y, grid.cellSize.z)) / 4.;
        //        if (cells[c].beginOfTrianglesIndiciesArray == cells[c].endOfTrianglesIndiciesArray)
        //        sphere.albedo = vec4(1.0, 0.0, 0.0, 1.0);
        //        else
        //        sphere.albedo = vec4(0.0, 1.0, 0.0, 1.0);
        //        sphere.specular = vec4(vec3(0.1), 1.0);

        //if (cells[c].beginOfTrianglesIndiciesArray != cells[c].endOfTrianglesIndiciesArray)
        //        intersectRaySphere(ray, sphere, bestHit);


        for (uint t = cells[c].beginOfTrianglesIndiciesArray; t < cells[c].endOfTrianglesIndiciesArray; t++){
            uint j = trianglesIndicesInGrid[t];
            uint vert1 = trianglesFromMesh[j].vertexIndex1;
            uint vert2 = trianglesFromMesh[j].vertexIndex2;
            uint vert3 = trianglesFromMesh[j].vertexIndex3;

            Triangle triangle;
            triangle.vert0 = vec3(verticesFromMesh[vert1].x, verticesFromMesh[vert1].y, verticesFromMesh[vert1].z);
            triangle.vert1 = vec3(verticesFromMesh[vert2].x, verticesFromMesh[vert2].y, verticesFromMesh[vert2].z);
            triangle.vert2 = vec3(verticesFromMesh[vert3].x, verticesFromMesh[vert3].y, verticesFromMesh[vert3].z);
            triangle.albedo = vec3(0.7, 0.7, 0.7);
            triangle.specular = vec3(0.1);

            vec3 cellBegin = vec3(cell) * grid.cellSize + grid.gridBegin;
            vec3 cellEnd = vec3(cell + ivec3(1)) * grid.cellSize + grid.gridBegin;
            bool intersect = intersectTriangle(ray, triangle, bestHit);
            bool isHitInCell = bestHit.position.x > cellBegin.x && bestHit.position.y > cellBegin.y && bestHit.position.z > cellBegin.z && bestHit.position.x < cellEnd.x && bestHit.position.y < cellEnd.y && bestHit.position.z < cellEnd.z;

            vec3 cellPosition = vec3(cell) * grid.cellSize + grid.gridBegin + grid.cellSize/2.;
            float distanceToCell = distance(ray.origin, cellPosition) - length(grid.cellSize/2.);

            if (bestHit.dist < distanceToCell){
                return;
            }
        }

        uint k = (int(nextCrossingT.x < nextCrossingT.y) << 2) +
        (int(nextCrossingT.x < nextCrossingT.z) << 1) +
        (int(nextCrossingT.y < nextCrossingT.z));
        uint map[8] = { 2, 1, 2, 1, 2, 2, 0, 0 };
        uint axis = map[k];
        if (axis == 0) {
            cell.x += step.x;
            if (cell.x == exit.x) break;
            nextCrossingT.x += deltaT.x;
        } else if (axis == 1){
            cell.y += step.y;
            if (cell.y == exit.y) break;
            nextCrossingT.y += deltaT.y;
        } else if (axis == 2){
            cell.z += step.z;
            if (cell.z == exit.z) break;
            nextCrossingT.z += deltaT.z;
        }

    }

}



